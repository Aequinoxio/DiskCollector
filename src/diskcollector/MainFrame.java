/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package diskcollector;

import diskcollector.Worker.FilesystemActionWorker;
import diskcollector.Worker.FolderTreeReaderWorker;
import diskcollector.NodeTypes.BackupNodeInformation;
import diskcollector.NodeTypes.CollectionNodeInformation;
import diskcollector.NodeTypes.FileNodeInformation;
import diskcollector.NodeTypes.FilesystemNodeInformation;
import diskcollector.NodeTypes.FolderNodeInformation;
import diskcollector.NodeTypes.NodeInformation;
import diskcollector.NodeTypes.NodeType;
import diskcollector.UI.DlgAbout;
import diskcollector.UI.DlgFilesystemAction;
import diskcollector.UI.DlgSwingWorkerLog;
import java.awt.Cursor;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDate;
import java.util.Date;
import java.util.Enumeration;
import java.util.concurrent.ExecutionException;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeModel;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;

/**
 *
 * @author utente
 */
public class MainFrame extends javax.swing.JFrame implements TreeSelectionListener {

    DefaultMutableTreeNode m_selectedNode; // Nodo selezionato nel jtree
    private Enumeration m_searchingNodes;  // Enumeration per la ricerca, viene messo a null ogni volta che c'Ã¨ una modifica sui dati dell'albero
    private final String latestDBSaveParh = "";

    /**
     * Creates new form MainFrame
     */
    public MainFrame() {
        initComponents();

        //UIManager.put("Button.defaultButtonFollowsFocus", Boolean.TRUE);
        // Inizializzo il tree
        DefaultMutableTreeNode topNode = new DefaultMutableTreeNode(new NodeInformation(Constants.ROOT_STRING, NodeType.ROOT));
        DefaultTreeModel defaultTreeModel = new DefaultTreeModel(topNode);
        directoryTree.setModel(defaultTreeModel);
        directoryTree.addTreeSelectionListener(this);
        directoryTree.setCellRenderer(new NodeCellRenderer());
        // Uso la stessa azione del bottone cerca quando premo invio
        txtSearchText.addActionListener(this::btnSearchActionPerformed);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        btnDeleteNodeTree = new javax.swing.JButton();
        btnDeleteNodeTre = new javax.swing.JButton();
        txtSearchText = new javax.swing.JTextField();
        btnSearch = new javax.swing.JButton();
        btnViewLog = new javax.swing.JButton();
        jSplitPane1 = new javax.swing.JSplitPane();
        jScrollPane1 = new javax.swing.JScrollPane();
        directoryTree = new javax.swing.JTree();
        jScrollPane2 = new javax.swing.JScrollPane();
        txtDetails = new javax.swing.JTextArea();
        btnSaveTree = new javax.swing.JButton();
        btnLoadTree = new javax.swing.JButton();
        btnNewBackup = new javax.swing.JButton();
        btnInsertNodeTree = new javax.swing.JButton();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenu1 = new javax.swing.JMenu();
        mnuLoadDB = new javax.swing.JMenuItem();
        jMenuItem2 = new javax.swing.JMenuItem();
        mnu2About = new javax.swing.JMenu();
        mitmAbout = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setMinimumSize(new java.awt.Dimension(930, 730));
        setPreferredSize(new java.awt.Dimension(930, 800));

        btnDeleteNodeTree.setText("Cancella ramo");
        btnDeleteNodeTree.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnDeleteNodeTreeActionPerformed(evt);
            }
        });

        btnDeleteNodeTre.setText("Cancella Backup set");
        btnDeleteNodeTre.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnDeleteNodeTreActionPerformed(evt);
            }
        });

        txtSearchText.setText("Cerca");
        txtSearchText.setToolTipText("Usa una regexp per cercare nel DB");
        txtSearchText.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                txtSearchTextFocusGained(evt);
            }
        });

        btnSearch.setText("Cerca");
        btnSearch.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSearchActionPerformed(evt);
            }
        });

        btnViewLog.setText("Cancella tutto");
        btnViewLog.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnViewLogActionPerformed(evt);
            }
        });

        jSplitPane1.setMinimumSize(new java.awt.Dimension(640, 480));
        jSplitPane1.setPreferredSize(new java.awt.Dimension(640, 480));

        jScrollPane1.setMinimumSize(new java.awt.Dimension(500, 580));
        jScrollPane1.setPreferredSize(new java.awt.Dimension(500, 580));
        jScrollPane1.setViewportView(directoryTree);

        jSplitPane1.setLeftComponent(jScrollPane1);

        jScrollPane2.setMinimumSize(new java.awt.Dimension(580, 520));

        txtDetails.setEditable(false);
        txtDetails.setColumns(20);
        txtDetails.setLineWrap(true);
        txtDetails.setRows(5);
        jScrollPane2.setViewportView(txtDetails);

        jSplitPane1.setRightComponent(jScrollPane2);

        btnSaveTree.setText("Salva DB");
        btnSaveTree.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSaveTreeActionPerformed(evt);
            }
        });

        btnLoadTree.setText("Carica DB");
        btnLoadTree.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnLoadTreeActionPerformed(evt);
            }
        });

        btnNewBackup.setText("Nuovo Backup set");
        btnNewBackup.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnNewBackupActionPerformed(evt);
            }
        });

        btnInsertNodeTree.setText("Inserisci ramo");
        btnInsertNodeTree.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnInsertNodeTreeActionPerformed(evt);
            }
        });

        jMenu1.setText("File");

        mnuLoadDB.setText("Salva tutto il DB");
        mnuLoadDB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnuLoadDBActionPerformed(evt);
            }
        });
        jMenu1.add(mnuLoadDB);

        jMenuItem2.setText("Carica DB");
        jMenuItem2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem2ActionPerformed(evt);
            }
        });
        jMenu1.add(jMenuItem2);

        jMenuBar1.add(jMenu1);

        mnu2About.setText("About");

        mitmAbout.setText("About");
        mitmAbout.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mitmAboutActionPerformed(evt);
            }
        });
        mnu2About.add(mitmAbout);

        jMenuBar1.add(mnu2About);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jSplitPane1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(btnNewBackup)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnDeleteNodeTre)
                        .addGap(18, 18, 18)
                        .addComponent(btnInsertNodeTree)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnDeleteNodeTree)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnViewLog)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 166, Short.MAX_VALUE)
                        .addComponent(btnSaveTree)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnLoadTree))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(txtSearchText)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnSearch)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnDeleteNodeTree)
                    .addComponent(btnDeleteNodeTre)
                    .addComponent(btnViewLog)
                    .addComponent(btnSaveTree)
                    .addComponent(btnLoadTree)
                    .addComponent(btnNewBackup)
                    .addComponent(btnInsertNodeTree))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(txtSearchText, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(btnSearch))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSplitPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 481, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Inserisce un subtree controllando che il nodo padre sia un backup node
     *
     * return True se il sotto albero Ã¨ stato inserito altrimenti false
     *
     * @throws InterruptedException
     * @throws ExecutionException
     */
    private boolean insertSubTree() throws InterruptedException, ExecutionException {
        DefaultMutableTreeNode selectedNode = (DefaultMutableTreeNode) directoryTree.getLastSelectedPathComponent();

        //Nessuna selezione o selezionato un nodo che non Ã¨ un backup set
        if (selectedNode == null || ((NodeInformation) selectedNode.getUserObject()).getType() != NodeType.BACKUP) {
            JOptionPane.showMessageDialog(this, "Selezionare un nodo Backup", "Informazione", JOptionPane.WARNING_MESSAGE);
            return false;
        }

        JFileChooser chooser = new JFileChooser();
        chooser.setCurrentDirectory(new java.io.File("."));
        chooser.setDialogTitle("Directory da leggere");
        chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        //
        // disable the "All files" option.
        //
        chooser.setAcceptAllFileFilterUsed(false);
        //    
        if (chooser.showOpenDialog(this) != JFileChooser.APPROVE_OPTION) {
            return false;
        }

        DefaultTreeModel defaultTreeModel = (DefaultTreeModel) directoryTree.getModel();
        DefaultMutableTreeNode topNode
                = (m_selectedNode == null) ? (DefaultMutableTreeNode) defaultTreeModel.getRoot() : m_selectedNode;

        //DefaultMutableTreeNode topNodeTemp = new DefaultMutableTreeNode(new EmptyNodeInformation()); // Nodo temporaneo
        DefaultMutableTreeNode topNodeTemp = new DefaultMutableTreeNode(new BackupNodeInformation()); // Nodo temporaneo

        this.setCursor(new Cursor(Cursor.WAIT_CURSOR));
        FolderTreeReaderWorker folderTreeReaderWorker = new FolderTreeReaderWorker(Paths.get(chooser.getSelectedFile().getAbsolutePath()), topNodeTemp);
        DlgSwingWorkerLog dlgSwingWorkerLog = new DlgSwingWorkerLog(this, true, folderTreeReaderWorker);

        dlgSwingWorkerLog.startWorkerAndShowDialog();

        if (folderTreeReaderWorker.isDone() && !folderTreeReaderWorker.isCancelled()) {
            // Aggiorno i dati del backupset
            if (((NodeInformation) topNode.getUserObject()).getType() != NodeType.BACKUP) {
                try {
                    throw new Exception("Qui non dovrei arrivare mai");
                } catch (Exception ex) {
                    Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE, null, ex);
                }
            }

            BackupNodeInformation bkpTemp = (BackupNodeInformation) topNodeTemp.getUserObject();  // Il primo Ã¨ sicuramenteun backup
            BackupNodeInformation bkpCurrentTemp = (BackupNodeInformation) topNode.getUserObject(); // se arrivo qui anche questo Ã¨ un backup

            bkpCurrentTemp.setFilesTotal(bkpCurrentTemp.getFilesTotal() + bkpTemp.getFilesTotal());
            bkpCurrentTemp.setFoldersTotal(bkpCurrentTemp.getFoldersTotal() + bkpTemp.getFoldersTotal() + 1); // Aggiungo anche la prima folder
            bkpCurrentTemp.setSizeTotal(bkpCurrentTemp.getSizeTotal() + bkpTemp.getSizeTotal());

            topNode = (DefaultMutableTreeNode) folderTreeReaderWorker.get().getChildAt(0); // Carico tutti i sottonodi dell'albero creato con il placeholder 
            // Oppure
            //topNode.add((MutableTreeNode) topNodeTemp.getFirstChild());
            folderTreeReaderWorker.sortTree(topNode);
            selectedNode.add(topNode);
        } else {
            topNodeTemp.removeAllChildren(); // Per sicurezza e liberare memoria cancello tutti i figli se ho avuto problemi
        }

        this.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
        ((DefaultTreeModel) directoryTree.getModel()).reload();
        m_searchingNodes = null;

        return true;
    }

    private void btnDeleteNodeTreeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnDeleteNodeTreeActionPerformed
       
        deleteSubTree();

        m_searchingNodes = null; 
    }//GEN-LAST:event_btnDeleteNodeTreeActionPerformed

    private void btnSearchActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSearchActionPerformed
        DefaultMutableTreeNode node = searchNode(txtSearchText.getText());
        if (node != null) {
            TreeNode[] nodes = ((DefaultTreeModel) directoryTree.getModel()).getPathToRoot(node);
            TreePath path = new TreePath(nodes);
            directoryTree.scrollPathToVisible(path);
            directoryTree.setSelectionPath(path);

        } else {
            JOptionPane.showMessageDialog(this, "Non ho trovato nulla", "Ricerca", JOptionPane.WARNING_MESSAGE);
            m_searchingNodes = null;
            //System.out.println("Node with string " + txtSearchText.getText() + " not found");
        }
    }//GEN-LAST:event_btnSearchActionPerformed

    private void btnSaveTreeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSaveTreeActionPerformed
        saveTheTree();
    }//GEN-LAST:event_btnSaveTreeActionPerformed

    private void btnLoadTreeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnLoadTreeActionPerformed
        openTheTree();
    }//GEN-LAST:event_btnLoadTreeActionPerformed

    private void btnViewLogActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnViewLogActionPerformed
        int val = JOptionPane.showConfirmDialog(this, "Conferma", "Cancello tutto?", JOptionPane.OK_CANCEL_OPTION);
        if (val != JOptionPane.OK_OPTION) {
            return;
        }
        ((DefaultMutableTreeNode) directoryTree.getModel().getRoot()).removeAllChildren();
        ((DefaultTreeModel) directoryTree.getModel()).reload();
        m_searchingNodes = null;
    }//GEN-LAST:event_btnViewLogActionPerformed

    private void btnNewBackupActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnNewBackupActionPerformed

        // Personalizzo la dialog
        JTextField txtBackupSetName = new JTextField();
        JTextArea txtBackupSetDescription = new JTextArea(10, 50);
        //JPasswordField password = new JPasswordField();
        final JComponent[] inputs = new JComponent[]{
            new JLabel("Nome Backup Set"),
            txtBackupSetName,
            new JLabel("Descrizione Backup Set"),
            txtBackupSetDescription
        };
        int result = JOptionPane.showConfirmDialog(this, inputs, "Inserimendo dati Backup Set", JOptionPane.OK_CANCEL_OPTION);

        String nome;
        String desc;
        if (result == JOptionPane.OK_OPTION) {
            nome = txtBackupSetName.getText().trim();
            desc = txtBackupSetDescription.getText().trim();
        } else {
            return;
        }

//If a string was not returned, return.
        if ((nome == null) || (nome.length() == 0)) {
            return;
        }

//If you're here, the return value was the string.
        DefaultMutableTreeNode defaultMutableTreeNode = (DefaultMutableTreeNode) directoryTree.getModel().getRoot();
        BackupNodeInformation backupNodeInformation = new BackupNodeInformation(nome, desc);
        backupNodeInformation.setRetrievingDate(new Date(LocalDate.now().toEpochDay())); // TODO: trucchetto da verificare meglio come gestirlo

        defaultMutableTreeNode.add(new DefaultMutableTreeNode(backupNodeInformation));

        ((DefaultTreeModel) directoryTree.getModel()).reload();
    }//GEN-LAST:event_btnNewBackupActionPerformed

    private void btnDeleteNodeTreActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnDeleteNodeTreActionPerformed

        deleteSubTree();
    }//GEN-LAST:event_btnDeleteNodeTreActionPerformed

    private void btnInsertNodeTreeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnInsertNodeTreeActionPerformed
        try {
            TreePath tp = directoryTree.getSelectionPath();
            if (insertSubTree()) {
                DefaultMutableTreeNode node = (DefaultMutableTreeNode) directoryTree.getLastSelectedPathComponent();
//                BackupNodeInformation backupNodeInformation = (BackupNodeInformation) node.getUserObject();

                // Aggiorno e visualizzo il jtree
                directoryTree.setSelectionPath(tp);
                directoryTree.scrollPathToVisible(tp);
                directoryTree.expandPath(tp);
            }
            
        } catch (InterruptedException | ExecutionException ex) {
            Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_btnInsertNodeTreeActionPerformed

    private void mitmAboutActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mitmAboutActionPerformed

        JDialog dialog = new DlgAbout(this, true);
        dialog.setVisible(true);

    }//GEN-LAST:event_mitmAboutActionPerformed

    private void mnuLoadDBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnuLoadDBActionPerformed
        saveTheTree();
    }//GEN-LAST:event_mnuLoadDBActionPerformed

    private void jMenuItem2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem2ActionPerformed
        openTheTree();
    }//GEN-LAST:event_jMenuItem2ActionPerformed

    private void txtSearchTextFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_txtSearchTextFocusGained
//        txtSearchText.setText("");
    }//GEN-LAST:event_txtSearchTextFocusGained

    /**
     * Cancella il subTree selezionato
     */
    private void deleteSubTree() {
        DefaultMutableTreeNode node = (DefaultMutableTreeNode) directoryTree.getLastSelectedPathComponent();
        if (node == null) { //Nothing is selected.     
            JOptionPane.showMessageDialog(this, "Selezionare un nodo", "Attenzione", JOptionPane.WARNING_MESSAGE);
            return;
        }

        // Cancello solo i nodi Backup o folder TODO: Da rivedere sulla base dell'UX
        NodeType nt = ((NodeInformation) node.getUserObject()).getType();
        if (nt == NodeType.BACKUP || nt == NodeType.FOLDER) {
            int val = JOptionPane.showConfirmDialog(
                    this,
                    "Cancello il sottoramo?",
                    "Conferma",
                    JOptionPane.YES_NO_OPTION);
            if (val != JOptionPane.YES_OPTION) {
                return;
            }
        } else {
            JOptionPane.showMessageDialog(this, "Selezionare un nodo Backup set o Folder", "Attenzione", JOptionPane.WARNING_MESSAGE);
            return;
        }

        // Salvo il Parent per poter lasciare aperto il tree
        TreeNode treeNodeParent = node.getParent();
        // Sono sulla root per cui non la cancello
        if (treeNodeParent == null) {
            JOptionPane.showMessageDialog(
                    this,
                    "Non Ã¨ possibile cancellare questo nodo",
                    "Attenzione",
                    JOptionPane.WARNING_MESSAGE);
            return;
        }

        // Salvo la posizione del fratello per espanderlo dopo aver cancellato il nodo
        DefaultMutableTreeNode nodeSibling = node.getNextSibling(); // Per aprire il fratello
        if (nodeSibling == null) {
            nodeSibling = (DefaultMutableTreeNode) node.getParent();
        }

        updateParentNode((DefaultMutableTreeNode) treeNodeParent, (DefaultMutableTreeNode) node);

        // Ok a questo punto posso cancellare il nodo
        node.removeFromParent();

        ((DefaultTreeModel) directoryTree.getModel()).reload(treeNodeParent);
        m_searchingNodes = null; 

        // Espando il fratello, visto che recupero comunque il nodo padre dovrei sempre passare l'if
        if (nodeSibling != null) {
            TreeNode[] nodes = ((DefaultTreeModel) directoryTree.getModel()).getPathToRoot(nodeSibling);
            TreePath path = new TreePath(nodes);
            directoryTree.scrollPathToVisible(path);
            directoryTree.setSelectionPath(path);
        }
    }

    private void updateParentNode(DefaultMutableTreeNode parentTreeNode, DefaultMutableTreeNode actualTreeNode) {
        NodeType nt = ((NodeInformation) actualTreeNode.getUserObject()).getType();
// Calcolo i parametri da aggiornare
//        long filesTotal = 0;
//        long foldersTotal = 0;
//        long sizeTotal = 0;

        switch (nt) {
            case FOLDER:
            case BACKUP:
                CollectionNodeInformation ob = (CollectionNodeInformation) actualTreeNode.getUserObject();
                //FolderNodeInformation ob1 = (FolderNodeInformation) node.getUserObject();
//                filesTotal = ob.getFilesTotal();
//                foldersTotal = ob.getFoldersTotal();
//                sizeTotal = ob.getSizeTotal();
                
                TreeNode[] nodePath = actualTreeNode.getPath();
                // Ciclare dal secondo nodo al penultimo: il primo Ã¨ la root mentre l'ultimo Ã¨ il nodo da cancellare
                long filesTotalTemp = 0;
                long foldersTotalTemp = 0;
                long sizeTotalTemp = 0;
                DefaultMutableTreeNode nodeTemp;
                CollectionNodeInformation cniTemp;
                nodeTemp = (DefaultMutableTreeNode) nodePath[nodePath.length - 1];
                cniTemp = (CollectionNodeInformation) nodeTemp.getUserObject();

                filesTotalTemp = cniTemp.getFilesTotal();
                foldersTotalTemp = cniTemp.getFoldersTotal();
                sizeTotalTemp = cniTemp.getSizeTotal();

                CollectionNodeInformation cniTempParent;
                DefaultMutableTreeNode nodeTempParent;
                for (int i = nodePath.length - 2; i >= 1; i--) { // Salto il primo e l'ultimo livello (Nodo Radice e foglia da cancellare risoettivamente)
                    nodeTempParent = (DefaultMutableTreeNode) nodePath[i];
                    cniTempParent = (CollectionNodeInformation) nodeTempParent.getUserObject();
                    cniTempParent.setFilesTotal(cniTempParent.getFilesTotal() - filesTotalTemp);
                    cniTempParent.setFoldersTotal(cniTempParent.getFoldersTotal() - foldersTotalTemp - 1); // Elimino anche la subdir stessa
                    cniTempParent.setSizeTotal(cniTempParent.getSizeTotal() - sizeTotalTemp);
                }

                // Aggiorno il nodo padre
                //DefaultMutableTreeNode dmtn = (DefaultMutableTreeNode) parentTreeNode;
                NodeInformation parentNode = (NodeInformation) parentTreeNode.getUserObject();

                // Verifico se sia un container (probabilmente p superfluo)
                switch (parentNode.getType()) {
                    case FOLDER:
                    case BACKUP:
                    case ROOT:

                        break;
                    default: // Se sono qui qualcosa Ã¨ andato molto storto per cui non faccio nulla
                        JOptionPane.showMessageDialog(
                                this,
                                "Qualcosa Ã¨ andato molto storto, il nodo da aggiornare non Ã¨ nÃ© un folder nÃ© un backup, non faccio nulla",
                                "Attenzione",
                                JOptionPane.WARNING_MESSAGE);
                        return;
                }

                // Aggiorno le subdir dirette del parent
                // PROBABILE BUG, se il nodo non Ã¨ nÃ© folder nÃ© backup ho un problema (provo a chiamare il metodo comune tra backup node e filde rnode)
                if (parentNode.getType() == NodeType.FOLDER) {
                    //FolderNodeInformation folderNodeTemp = (FolderNodeInformation) parentTreeNode.getUserObject();
                    FolderNodeInformation folderNodeTemp = (FolderNodeInformation) parentNode; // Per comoditÃ 
                    folderNodeTemp.setFirstSubFolders(folderNodeTemp.getFirstSubFolders() - 1);
                }

                break;

            default: // Se sono qui qualcosa Ã¨ andato molto storto per cui non faccio nulla
                JOptionPane.showMessageDialog(
                        this,
                        "Qualcosa Ã¨ andato molto storto, il nodo da cancellare non Ã¨ nÃ© un folder nÃ© un backup non faccio nulla",
                        "Attenzione",
                        JOptionPane.WARNING_MESSAGE);
                return;
        }

    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                new MainFrame().setVisible(true);
            }
        });
    }

    /**
     * Recupera i dettagli e li mostra 
     *
     * @param e Evento
     */
    @Override
    public void valueChanged(TreeSelectionEvent e) {
        //Returns the last path element of the selection.
        //This method is useful only when the selection model allows a single selection.
        DefaultMutableTreeNode node = (DefaultMutableTreeNode) directoryTree.getLastSelectedPathComponent();

        if (node == null) //Nothing is selected.     
        {
            return;
        }

        NodeInformation nodeInfo = (NodeInformation) node.getUserObject();
        m_selectedNode = node;
        String fileDetails;
        StringBuilder sb = new StringBuilder();

        // sb.append(nodeInfo.toString());
        if (node.isRoot()) {
            sb = sb.append(" << ROOT >>").append("\n");
        } else {

            switch (nodeInfo.getType()) {
                case BACKUP: {
                    BackupNodeInformation backupNodeTemp = (BackupNodeInformation) nodeInfo;
                    sb.append("<< Backup set  >>").append("\n");
                    sb.append(nodeInfo.toString()).append("\n");
                    sb.append(backupNodeTemp.getDetails()).append("\n");
                    sb.append("Files totali: ").append(String.valueOf(backupNodeTemp.getFilesTotal())).append("\n");
                    sb.append("Directory totali: ").append(String.valueOf(backupNodeTemp.getFoldersTotal())).append("\n");
                    sb.append("Dimensioni totali: ").append(String.valueOf(backupNodeTemp.getSizeTotal())).append("\n");
                }
                break;
                case FOLDER:
                    sb = sb.append(" << DIRECTORY >>").append("\n");
                    //sb.append(nodeInfo.toString()).append("\n");
                    sb.append(nodeInfo.getDisplayString()).append(" (");
                    sb.append(((FilesystemNodeInformation) nodeInfo).getPath()).append(")\n");

                    sb.append(String.valueOf(((FolderNodeInformation) nodeInfo).getFirstFilesInFolder())).append(" files in folder \n");
                    sb.append(String.valueOf(((FolderNodeInformation) nodeInfo).getFirstFilesSizeInFolder())).append(" file size in folder\n");
                    sb.append(String.valueOf(((FolderNodeInformation) nodeInfo).getFirstSubFolders())).append(" subfolders in folder\n");
                    sb.append(String.valueOf(((FolderNodeInformation) nodeInfo).getFilesTotal())).append(" files totali sotto il folder \n");
                    sb.append(String.valueOf(((FolderNodeInformation) nodeInfo).getSizeTotal())).append(" file size totali nel folder\n");
                    sb.append(String.valueOf(((FolderNodeInformation) nodeInfo).getFoldersTotal())).append(" folder totali nel folder\n");

                    break;
                case FILE: {
                    sb = sb.append(" << FILE >>").append("\n");
                    sb.append(nodeInfo.getDisplayString()).append(" (");
                    sb.append(((FilesystemNodeInformation) nodeInfo).getPath()).append(")\n");
                    sb.append("File size: ").append(String.valueOf(((FileNodeInformation) nodeInfo).getSize())).append("\n");
                }
                break;

                case EMPTY_PLACEHOLDER: {
                    sb.append(nodeInfo.toString()).append("\n");
                }
                break;

                case GENERIC: {
                    sb.append(nodeInfo.toString()).append("\n");
                    //System.out.println("");
                }
                break;

            }
        }
//        if (nodeInfo instanceof FileNodeInformation) {
//            Date d = ((FileNodeInformation) nodeInfo).getLastModifiedDateTime();
//            sb.append("\n").append("LastModified: ").append(d.toString()).append("\n");
////            System.out.println( nodeInfo.getDisplayString());
//        }
        if (nodeInfo.getType() == NodeType.FILE || nodeInfo.getType() == NodeType.FOLDER) {
            Date d = new Date(((FilesystemNodeInformation) nodeInfo).getCreateDateTimeMillis());
            sb.append("Created: ").append(d.toString()).append("\n");
            d = new Date(((FilesystemNodeInformation) nodeInfo).getLastModifiedDateTimeMillis());
            sb.append("Last modified time: ").append(d.toString()).append("\n");
            d = new Date(((FilesystemNodeInformation) nodeInfo).getLastAccessedDateTimeMillis());
            sb.append("Last access time: ").append(d.toString()).append("\n");
        }

        fileDetails = sb.toString();
        displayDetails(fileDetails);
    }

    private void displayDetails(String detail) {
        txtDetails.setText(detail);
    }

    /**
     *
     * @param nodeStr
     * @return
     */
    public DefaultMutableTreeNode searchNode(String nodeStr) {
        DefaultMutableTreeNode node = null;
        //Enumeration e = ((DefaultMutableTreeNode) directoryTree.getModel().getRoot()).depthFirstEnumeration();
        if (m_searchingNodes == null || !m_searchingNodes.hasMoreElements()) {
            m_searchingNodes = ((DefaultMutableTreeNode) directoryTree.getModel().getRoot()).depthFirstEnumeration();
        }
        Pattern pattern = Pattern.compile(nodeStr);
        while (m_searchingNodes.hasMoreElements()) {
            node = (DefaultMutableTreeNode) m_searchingNodes.nextElement();
            Matcher matcher = pattern.matcher(node.getUserObject().toString());
            if (matcher.find()) {
                return node;
            }
        }
        return null;
    }
    
    /**
     *
     */
    public void saveTheTree() {

        boolean toOverwrite = false;

        JFileChooser chooser = new JFileChooser();
        Path currentPath = Paths.get(Constants.getInstance().getLatestSavePath() + File.separator + Constants.getInstance().getLatestSaveFilename());
        chooser.setSelectedFile(new File(currentPath.toAbsolutePath().toString()));
        chooser.setDialogTitle("Salvo il DB");
        //chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        //
        // disable the "All files" option.
        //
        chooser.setAcceptAllFileFilterUsed(true);

        //    
        if (chooser.showSaveDialog(this) != JFileChooser.APPROVE_OPTION) {
            return;
        }

        if (chooser.getSelectedFile().exists()) {
            int val = JOptionPane.showConfirmDialog(
                    this,
                    "Il file esiste, lo sovrascrivo?",
                    "Conferma",
                    JOptionPane.YES_NO_OPTION);
            if (val != JOptionPane.YES_OPTION) {
                return;
            }
            toOverwrite = true;
        }

        Constants.getInstance().setLatestSavePath(chooser.getSelectedFile().getParent());
        Constants.getInstance().setLatestSaveFilename(chooser.getSelectedFile().getName());

        TreeModel tm = directoryTree.getModel();   //tree is of type MyTree which extends JTree. It creates a tree from an XML document

//        try {
//            try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(chooser.getSelectedFile().getAbsolutePath()))) {
//                out.writeObject(tm);//the actual tree object
//                out.flush();
//            } //the actual tree object
//        } catch (IOException e) {
//            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, e);
//        }
        FilesystemActionWorker filesystemActionWorker = new FilesystemActionWorker(chooser.getSelectedFile().getAbsolutePath(), false);
        filesystemActionWorker.setObjectToWrite(tm);

        DlgFilesystemAction dlgFilesystemAction = new DlgFilesystemAction(this, true, filesystemActionWorker, false);

        dlgFilesystemAction.startWorkerAndShowDialog(); // Aspetto che il thread finisca
//        try {
//            filesystemActionWorker.get();
//        } catch (InterruptedException | ExecutionException ex) {
//            Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE, null, ex);
//        }
        if (filesystemActionWorker.isCancelled()) {
            String msg = "Nessun file Ã¨ stato salvato" + (toOverwrite ? ". Il file esistente Ã¨ stato conservato" : "");
            JOptionPane.showMessageDialog(this, msg, "Attenzione", JOptionPane.OK_OPTION);
        }
    }

    /**
     *
     */
    public void openTheTree() {
        JFileChooser chooser = new JFileChooser();
        Path currentPath = Paths.get(Constants.getInstance().getLatestSavePath() + File.separator + Constants.getInstance().getLatestSaveFilename());
        chooser.setSelectedFile(new File(currentPath.toAbsolutePath().toString()));
        chooser.setDialogTitle("Carico il DB");
        //chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        //
        // disable the "All files" option.
        //
        chooser.setAcceptAllFileFilterUsed(true);

        //    
        if (chooser.showOpenDialog(this) != JFileChooser.APPROVE_OPTION) {
            return;
        }

        // Salvo la posizione corrente
        Constants.getInstance().setLatestSavePath(chooser.getSelectedFile().getParent());
        Constants.getInstance().setLatestSaveFilename(chooser.getSelectedFile().getName());

        //latestDBSaveParh = chooser.getSelectedFile().getParent();
        m_searchingNodes = null; // reinizializzo la ricerca

        try {
            TreeModel atm;

            // Avvio i componenti per caricare i dati (worker e dialog)
            FilesystemActionWorker filesystemActionWorker = new FilesystemActionWorker(chooser.getSelectedFile().getAbsolutePath(), true);
            DlgFilesystemAction dlgFilesystemAction = new DlgFilesystemAction(this, true, filesystemActionWorker, true);

            dlgFilesystemAction.startWorkerAndShowDialog(); // Aspetto che il thread finisca

            // Sembra che si blocchi comunque anche se il thread Ã¨ stato cancellato
            if (filesystemActionWorker.isCancelled()) {
                return;
            }

            atm = filesystemActionWorker.get(); // Recupero il treemodel            
            if (atm == null) { // Se Ã¨ nullo esco in quanto ci potrebbe essere stato un problema nel leggere il file
                return;
            }

            // A questo punto agisco
            // Cancello tutto il tree
            DefaultTreeModel defaultTreeModel = new DefaultTreeModel(null);
            directoryTree.setModel(defaultTreeModel);
            ((DefaultTreeModel) directoryTree.getModel()).reload();

            // Aggiono il modello
            directoryTree.setModel(atm);
            ((DefaultTreeModel) directoryTree.getModel()).reload();

        } catch (Exception e) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, e);
        }
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnDeleteNodeTre;
    private javax.swing.JButton btnDeleteNodeTree;
    private javax.swing.JButton btnInsertNodeTree;
    private javax.swing.JButton btnLoadTree;
    private javax.swing.JButton btnNewBackup;
    private javax.swing.JButton btnSaveTree;
    private javax.swing.JButton btnSearch;
    private javax.swing.JButton btnViewLog;
    private javax.swing.JTree directoryTree;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenuItem jMenuItem2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JSplitPane jSplitPane1;
    private javax.swing.JMenuItem mitmAbout;
    private javax.swing.JMenu mnu2About;
    private javax.swing.JMenuItem mnuLoadDB;
    private javax.swing.JTextArea txtDetails;
    private javax.swing.JTextField txtSearchText;
    // End of variables declaration//GEN-END:variables

}
